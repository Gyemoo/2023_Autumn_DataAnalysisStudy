### 3.6 람다를 활용한 데이터 처리 응용 예제
+ 람다는 하나 이상의 함수를 속성으로 사용할 수 있는 고차 함수를 통한 내부 컬렉션 작업에 매우 유용하기에 람다와 판다스의 map(), apply(), applymap()함수를 조합하면 데이터를 유연하게 처리할 수 있는 로직을 스스로 만들 수 있음.
+ map()함수는 단일 컬럼에 적용이 가능하며 하나의 변수의 고윳값을 딕셔너리 타입으로 지정한 값으로 매칭해서 변경할 때 많이 사용함.
+ 같은 성격의 컬럼이 많은 경우에는 lambda와 applymap()의 조합을 이용하면 됨.
 
## 04 데이터 병합과 재형성
### 4.1 데이터 병합
+ 2개 데이터를 위아래로 연결; concat() > append()
+ 인덱스가 이상하게 데이터가 연결된 경우; ignore_index=True
+ 어떤 데이터에서 온 것인지 구분하는 표시; keys=['data_1', 'data_2']
+ 2개 데이터의 교집합 부분만 얻고 싶다면; join='inner'
+ 컬럼 기준으로 좌우로 연결; concat( , axis=1), merge(), join()
+ 이름이 같은 컬럼을 사전에 변경하지 않은 경우에는 접미사 _x 또는 _y가 붙음.
+ 서로 다른 key 컬럼을 가진 경우에는 매개변수 left_on 과 right_on을 사용하여 key 컬럼을 명시해주어야 함.
+ 삭제할 때; drop()
+ 기존 인덱스를 살리려면; merge( , left_index=True, right_index=True)
+ 결측값이 있는 위치에 값을 채워넣기 위해서; where()

### 4.2 데이터 재형성과 피벗
+ 컬럼을 인덱스로 교환하여 데이터를 피벗할 수 있음.
+ stack()함수를 사용하여 데이터의 컬럼을 인덱스로 만들 수 있고, unstack()함수를 활용해 다시 원 상태로 되돌릴 수 있음.
+ pivot()함수로 하나의 컬럼을 기준으로 몇 개의 데이터프레임을 생성하며 pivot_table()을 활용해서 동일한 집계 결과 생성이 가능함.
+ melt()함수로 사용자가 지정한 하나의 컬럼을 제외한 여러 개의 컬럼을 하나로 병합하여 원본 데이터보다 긴 형태의 데이터 생성이 가능함.
+ melt()로 재구성된 데이터프레임을 원상태로 다시 되돌리고 싶으면 pivot()을 활용함.
+ 숫자 인덱스를 새로 생성하고 싶다면; reset_index()
+ 복합 개체를 개별 개체로 분리; explode() - 1개 컬럼을 기준으로 데이터를 분리함
+ 한번 분리한 후 추가적으로 분리를 더 하고 싶다면 explode()함수를 한번 더 적용하면 가능함.
________________________________________________________
> 함수 및 코드
+ map()이나 apply()함수 안에 lambda와 if.else구문을 조합하여 사용하면 조건부에 따라 값이 변경되게 할 수 있다.
```
titanic['Age'].apply(lambda x: 'Adult' if x >= 18 else 'Child')
```
+ join()함수를 활용할 때 왼쪽 프레임과 오른쪽 프레임에 겹치는 컬럼이 있다면 각각 접미사를 지정해줘야한다.
```
data_6.join(data_7, lsuffix='_left_key', rsuffix='_right_key')
```
+ var_name & value_name; 컬럼명 변경
+ id_vars & value_vars; 부분 컬럼만 사용하여 데이터 생성
________________________________________________________
> 느낀점 및 알게된점
+ 키 값이 같은 데이터가 여러 개 있는 경우에는 가능한 경우의 수 전체를 기준으로 하여금 조합을 만들어내서 데이터를 병합한다는 것을 알게 되었다.
+ 이름이 같더라도 키가 되면 안되는 열이 있다면 on으로 기준열을 명시해주어야 한다.
+ melt()를 사용했을 때 하나의 컬럼을 기준으로 모든 컬럼이 variable로 들어오며 해당 값이 value에 저장되어서 하나의 컬럼으로 축소되는 것이 신기했다.
