람다, 데이터 병합과 재형성, 피벗
=================
!!! 이하 내용은 기본적으로 다음의 코드가 작성되었음을 기준으로 합니다.

    import numpy as n
    import pandas as p
    import seaborn as s
    t = s.load_dataset('titanic')

# 1. 람다와 이를 응용한 데이터처리 응용
람다를 활용하면 복잡한 컬렉션 작업도 간단히 해결할 수 있다. 주로 map() 함수나 apply() 함수, applymap() 함수를 함께 활용한다.
## 단일 컬럼
단일 컬럼은 주로 map()을 사용한다. apply()를 사용해도 무방하다.

    t['fare_int']=t['Fare'].map(lamda x:int(x+x/1000))
    t['fare_int']=t['Fare'].apply(lamda x:int(x+x/1000))

apply를 사용하면 if 구문도 사용할 수 있다.

    t['A']=t['Age'].map(lamda x:'Adult' if x>19 else 'Child')

## 데이터 프레임
데이터프레임에서는 map() 대신 applymap()을 사용한다. apply는 그대로 사용 가능하다. 여기서는 람다로 사용한 조건이 원하는 컬럼 모두에 적용이 된다.

    t[['SibSp', 'Parch']].apply(lambda x: x.sum(), axis=1)
    t[['SibSp', 'Parch']].applymap(lambda x: x.sum(), axis=1)

# 2. 데이터 병합
데이터프레임 내에서 데이터가 꼭 깔끔하게 담겨있으란 법은 없다. 이런 데이터들을 우리가 연결하고 병합하여 깔끔한 모양으로 정리할 수 있다.
## 2개 데이터를 위아래로 연결
2개의 데이터를 컬럼에 관계없이 연결할 땐 주로 concat()을 쓴다. 데이터가 시리즈던, 데이터프레임이던 위아래로 깔끔하게 붙여버린다.

    d1=p.Series(['1', '2', '3'], index=[1, 2, 3])
    d2=p.Series(['4', '5', '6'], index=[4, 5, 6])
    p.concat([d1, d2])

 * 여기서 인덱스가 이상하다면 괄호 내 뒤에 , ignore_index=True 붙이면 인덱스가 깔끔하게 정렬된다.
 * 데이터가 어떤 쪽에서 왔는지를 구분하고 싶다면 괄호 내 뒤에 , keys=['d1', '2'] 붙이면 각 데이터의 시작점에 어떤 데이터 출신인지 이름이 붙는다.
 * 만약 컬럼이 다른 데이터를 붙이면 해당 컬럼이 없는 부분은 데이터가 결측값 NaN으로 들어간다. 만약 컬럼이 겹치는 것만 합치고 싶으면 뒤에 , join=inner 붙이면 된다.
append()는 concat()과는 다르게 특정 데이터를 기준으로 다른 데이터를 붙여준다. 다음과 같이 쓸 수 있다.

    d1.append(d2, ignore_index=True)

마찬가지로 컬럼이 다른 데이터를 붙이면 없는 부분은 결측값이 들어간다.
## 2개 데이터를 좌우로 연결
이쪽도 concat()을 사용하여 가능하다. 단, 뒤에 , axis=1을 붙여야 한다. 이 외에도 merge(), join()을 사용 가능하다.
 * merge()는 단순히 2개를 좌우로 붙이는 concat과 달리 공통된 컬럼을 기준으로 붙인다. 기본적으로는 하나라도 컬럼 값이 비는 데이터는 빼고 나오나, 뒤에 , how='outer'를 붙이는 것으로 빈 자리에 결측값을 넣어줄 수 있다.
 * join()은 특정 컬럼을 기준으로 병합하는 경우 사용한다. merge가 같은 컬럼은 합쳐서 나타낸다면 join은 그대로 옆에 붙여준다. 따라서 두 이름만 같은 컬럼이 값이 다르다면 다음과 같은 방법으로 두 컬럼을 분리해 합쳐줄 수 있다.

     d1.join(d2, lsuffix='_lk', rsuffix='_rk')

이러면 겹치는 두 컬럼의 이름 뒤에 각각 _lk, _rk가 붙어 구분이 된다.

# 3. 데이터 재형성과 피벗
데이터프레임은 다양한 방식으로 재배치와 피벗이 가능하다.
## 컬럼<->인덱스 교환
컬럼을 인덱스로, 인덱스를 컬럼으로 만들 수 있다.

    t.stack()

이러면 모든 컬럼들이 전부 로우로 세분화된다. 여기서 다시 되돌리려면 .unstack() 쓰면 된다.
## 데이터 피벗
특정 2개의 컬럼간의 관계를 설명하기 위해 한쪽을 로우, 다른쪽을 컬럼으로, 그리고 또 다른 하나를 값으로 만들어버리는 '피벗'을 할 수 있다.

    dt.pivot(index='로우', columns='컬럼', valus='값')

이러면 로우 쪽이 로우로, 컬럼 쪽이 컬럼으로, 값쪽이 값으로 들어간 새로운 데이터프레임이 나온다.

인상깊은 코드와 활용법
----------------------
.pivot()이 개인적으로 가장 인상깊었다. 이번에 피벗이라는 개념을 처음 알게 됬는데, 데이터프레임 내에서 명확하게 보기 힘든 두(세) 컬럼간의 관계를 좀 더 알기쉽게 나타낼 수 있게 해준다는 점이 흥미로웠다.        
한편 두 데이터를 아무렇게나 이어붙일 수 있는 .concat() 역시 신기했다.

느낀점
---------------
점점 판다스와 넘파이의 함수들이 손에 익어가는 한편으로는 아직도 종종 헷갈리곤 해 내가 정리한 글들을 자주 참고하게 되는 것 같다.        
다음주 발표 전에는 이번 주차 까지의 내용들을 모두 익혀놓겠다는 목표가 생겼다.
