numpy 및 pandas에 대한 예습
============
numpy 관련
-----------------
>numpy란? : 대용량 데이터 배열을 효율적으로 처리할 수 있는 라이브러리.
>+ 특별히 과학 계산을 위한 함수나 모델링 같은건 없지만 텐서플로우 등 과학 계산 시 필요한 주요 라이브러리들이 대부분 numpy를 사용하기 때문에 파이썬에서 계산과 연산을 위한 가장 중요한 토대가 되는 라이브러리라고 볼 수 있다.
>+ 사용 방법 : 간단히 다음과 같이 사용할 수 있다.

    import numpy
    import numpy as np

>  다른 라이브러리를 가져오듯이 import로 쉽게 사용할 수 있다. 사용 중 numpy 일일이 치는게 귀찮다면 as np를 이용해 np로 줄여 써도 된다.
>+ 배열 생성 방법 : 리스트 변수를 따로 만들고, 이를 numpy.array()를 이용해 넘파이 배열로 바꿀 수 있다.

    a = [1, 2, 3, 4, 5]
    npa = numpy.array(a)

>  위의 과정을 거쳐 npa를 출력해보면 array([1, 2, 3, 4, 5])라는 결과가 나온다.
> + 리스트를 만들 때 2차 이상으로 만들면 넘파이 배열도 그 차수에 맞춰서 나온다.
>  + 배열이름.ndim을 이용해 몇차 배열인지 출력할 수 있다.
>  + 배열이름.shape를 이용해 몇X몇 형태의 배열인지 출력할 수 있다. 가령 10X10 형태의 2차 배열이라면 (10, 10)이라는 출력값이 나온다.
>  + 배열이름.dtype을 이용해 내부 원소가 어떤 종류인지 출력할 수 있다. 다만, 그 크기가 같이 붙어나온다. 이를테면 정수형은 int32 아니면 int16 이런식으로.
>+ 기본적으로 0 아니면 1로 꽉 채워진 배열을 만들 수 있다. 이는 다음과 같은 명령어를 통해 가능하다.

    a = numpy.zeros(10)
    b = numpy.ones((10, 10, 10))

>  위에서 .numpy.zeros()는 0으로 채워진 배열, .ones()는 1로 채워진 배열을 만들어준다. 괄호 안에는 원하는 크기를 입력해주면 된다.
>+ 등차수열을 만들어내는 명령어도 있다. 이는 다음과 같이 사용한다.

    a = numpy.arange(10)
    b = numpy.arange(1, 10, 2)

>  a의 경우는 단순히 0부터 시작해 10 전까지 배열을 만들어내고, b의 경우는 1부터 시작해 10 전까지 공차가 2인 배열을 만들어준다.
>+ 넘파이 배열은 일반 리스트와는 다르게 내부의 원소가 전부 같은 타입이어야 한다. 정수면 정수만, 실수면 실수만.
>+ 넘파이 배열은 배열의 크기를 바꿀 수 없다. 이런 점에서 C언어의 배열과도 비슷하다.
>+ 위 2가지 장점 덕분에 리스트와는 다르게 메모리 소모가 작고 많은 데이터를 빠르게 처리할 수 있다는 장점이 있다.
>+ 따로 지정하지 않았을 경우 기본적으로 넘파이 배열은 float64 타입이다. 다만, 생성할 때 dtype을 이용해 형태를 정해줄 수 있다.

    a = numpy.array([1, 2, 3], dtype=numpy.int16)

>+ 넘파이 배열의 타입을 일시적으로 다른 것으로 변환하는 것이 가능하다. 이는 astype을 이용해 가능하다. 변경 과정에서 실수가 정수가 되는 경우 C언어처럼 소수점 아래가 증발한다.

    a = numpy.array([1, 2, 3], dtype=numpy.int16)
    aa = a.astype(float64)

>+ 배열끼리 연산을 실행할 수 있다.
> + 연산을 실행하는 배열들 간 크기가 같다면, 연산은 같은 위치에 있는 원소끼리 실행한다.
> + 연산을 실행하는 배열들 간 크기가 다른 경우는 브로드캐스팅이라고 지칭한다. <----이 부분 따로 공부 필요.
>+ 기본적으로 넘파이 배열도 인덱싱은 0번부터 들어간다. 따로 []를 이용해 원하는 위치의 원소만 뽑아올 수도 있고, [[찾고싶은거, 찾고싶은거]]의 형식으로 여러개를 뽑아오는 것도 된다. [시작:끝]의 형식으로 범위를 지정해 뽑아올 수도 있다.
> + 이렇게 뽑아온 것에 값을 대입해 넣으면 뭘 얼마나 뽑아왔던 간에 그 자리에 원하는 값으로 채워진다.
> + 다차원 배열의 경우 대괄호를 차원만큼 써도 되고, [1, 2, 3] 등의 형식으로 써도 나오긴 한다.
>  + 다차원 배열에서 :를 이용해 슬라이싱 할 경우, 대괄호 내부에서 ,를 써서 다차원 슬라이싱을 할 수 있다. 3X3 배열에다 [:2, :2]를 적용할 경우 1행 2행의 1열 2열만 남는다. [[0, 1], :2]등의 형식으로 0행, 1행만 남기고 썰거나 [:]만 써서 인덱스 전체를 선택할 수도 있다.
>+ random이라는 서브 모듈이 있다. 이 서브모듈은 엄청나게 많은 표본값을 생성하는 함수를 제공한다.
> + 기본적으로 다음과 같이 쓴다.

    numpy.random.쓰고싶은거
    
> + 난수 생성 시 시드값에 따라 난수 생성 알고리즘이 정해진다. 시드를 알면 나중에 같은 시드값을 써서 동일한 난수 표본을 뽑을 수 있다. 이 시드를 설정하는 방법은 다음과 같다.

    numpy.random.seed(1000)

> + 난수를 만들 수 있는 명령어 중 대표적으로는 rand(), randn(), randint()가 있다.
>  + rand는 균등분포로 실수 난수를 만들어준다.
>  + randn은 표준편차가 1이고 평균 0인 정규분포로 실수 난수를 만들어준다.
>  + randint는 정수 난수를 만들어준다.
>   + 기본적으로 randint(low, high, 배열 크기) 형식이다. high는 없어도 되며, 없을 경우 0과 low 사이 값을 알아서 뽑아준다.
>  + normal은 표준 정규분포로 실수 난수를 만들어준다.
> + 생성한 데이터의 순서를 무작위로 바꾸려면 .shuffle(배열이름)을 사용하면 된다.
> + 원하는 범위 내에서 무작위로 샘플링 해서 넘파이 배열을 만들고 싶으면 .choice(몇까지뽑을지, 몇개뽑을지, replace=true아니면false) 형식을 사용해 뽑을 수 있다. 여기서 replace는 중복/미중복 여부다.(디폴트는 중복)
>  + 괄호 맨 뒤에다 p=[내부 확률]을 적어주면 데이터 배열 각 원소의 선택 확률을 주작하는 것도 가능하다.
>  + 숫자만 되는건 아니고, 몇까지 뽑을지 부분에 원하는 리스트를 넣으면 그 리스트 안에서 뽑아간다.
>+ len(배열이름)으로 배열의 총 원소 개수를 출력할 수 있다.
>+ numpy.mean(배열이름)으로 표본 평균을 계산할 수 있다.
>+ numpy.median(배열이름)으로 중앙값을 계산할 수 있다. 짝수인 경우 중앙 두 값의 평균을 출력한다.
>+ numpy.std(배열이름)을 이용해 표준편차를 구할 수 있고, numpy.var(배열이름)을 이용해 분산을 구할 수 있다. 확통하면서 분산, 표준편차 구하기 짜증났던 사람들은 이제 이걸 적극적으로 활용하자.
>+ numpy.min(배열이름)으로 최소값을 구할 수 있고, 같은 방식으로 max로 최대값을 구할 수 있다.
>+ 배열이름.sum()을 이용해 배열 전체 또는 특정 원소들의 합을 구할 수 있다. 반복문 돌릴 필요가 없다!
>+ 배열이름.cumsum()은 원소의 누적합의 배열을, 배열이름.cumprod()는 원소의 누적곱의 배열을 반환해준다.
>+ numpy.percentile(배열이름, 몇퍼센트)를 이용해 몇퍼센트의 백분위수를 구할 수 있다.
>+ .any()와 .all()을 이용하면 불리언값을 출력할 수 있다. 각각 하나 이상 0이 아닌지, 싹다 0이 아닌지 를 리턴한다.
>+ 배열이름.sort()를 이용해 정렬이 된다. 이건 리스트도 가능.
pandas 관련
----------------
>pandas란? : numpy와 비슷한 데이터 처리 라이브러리이다.
>+ numpy와는 달리 다양한 타입이 섞인 데이터를 처리 가능하다는게 가장 큰 차이.
>+ 이것도 import pandas로 사용 가능하다. 일일이 pandas 치는게 귀찮은 사람들은 as pd를 써서 간단히 pd만 치기도 한다.
>+ pandas에는 크게 2가지의 데이터 구조가 있다.
> + 시리즈 : 라벨이 붙은 1차원 데이터 구조이다. 다음과 같은 방식으로 선언할 수 있다.

    a = [1, 2, 3, 4, 5]
    sa = pandas.Series(a)

>  여기서 sa를 출력하면 다음과 같은 결과가 나온다.

    0  1
    1  2
    2  3
    3  4
    4  5
    dtype:  int64

>  여기서 왼쪽이 인덱스, 오른쪽이 값이다. C언어 배열이나 파이썬의 리스트, 넘파이배열과 동일하게 0부터 붙는다.
>  + 시리즈.index로 시리즈의 인덱스 시작과 끝 그리고 몇칸씩 뛰는지를, 시리즈.values로 값과 타입을 알 수 있다.
>  + 간단하게 위와 같이 만들 수 있으나, 더 세세하게 들어가면 아래처럼 이런 형식을 지정해 만들고 싶은 대로 만들 수 있다. 값을 넣는 건 기본이고 인덱스를 원하는대로 붙여주는 것에다 이름까지 지어주는 짓도 가능하다. 참고로 딕셔너리를 사용해 만들면 인덱스를 지정할 필요 없이 값에 딕셔너리를 입력해주면 알아서 인덱스도 딕셔너리의 것을 계승해간다.

     pandas.Series(data=넣을값, index=붙일인덱스, name=시리즈의이름)

>  + 다시 리스트로 바꾸고 싶으면 시리즈이름.tolist()로 바꿔버리면 된다.
> + 데이터프레임 : 라벨이 가로 세로로 붙은 2차원 데이터 구조이다. 대충 인덱스가 같은 시리즈 여러개를 갖다붙였다고 보면 편하다. 다음과 같은 방식으로 선선할 수 있다.

    (대충 a라는 이름의 값이 리스트로 들어가있는 딕셔너리를 만들었다고 친다)
    dfa = pandas.DataFrame(a)

>  여기서 딕셔너리의 인덱스는 가로쪽 인덱스로 들어간다.
>  + 여기서 값 옆에 , 치고 columns=[원하는 순서] 넣어주면 원하는 순서로 바뀐다.
>  + 딕셔너리에 값을 시리즈로 넣어서 만들어주면 데이터프레임의 세로 인덱스는 시리즈의 인덱스를 계승한다.
>+ pandas는 고유의 데이터타입을 쓴다. 대표적으로 다음과 같은 것들이 있다.
> + object : 파이썬 객체형
> + string : 문자, 문자열 타입
> + int64 : 넘파이의 정수형과 같다.
> + float64 : 넘파이의 실수형과 같다.
> + bool : 불리언타입
> + category : 범주형 데이터타입. 순서나 레벨을 가지는것도 가능.
> + datatime64 : 날짜값과 시간값이 있는 데이터타입
> + timedelta[ns] : 2개의 데이터타임의 사잇값이나 차잇값을 표현하는 데이터타입
> + 판다스는 넘파이나 생 파이썬과 비교했을때 가장 많은 데이터타입을 가진다.

인상적인 코드와 활용법
-----------------
중학생때부터 C언어나 파이썬으로만 코딩을 해온 입장에서는 zeros(), ones(), arange()가 가장 흥미로웠다. 이전까지 배열에 값을 채울 때는 일일이 for문이나 while문을 이용해 하나씩 수동으로 넣어주거나, 아니면 아예 다 같은 값으로만 넣어줬어야 했는데, 이런 점에서 저 세 함수 특히 arange가 가장 쓰기 편하고, 번거로운 단계들을 없애줘 코딩시간 단축에도 쓰면 좋을 것 같다는 생각이 들었다.
+ 활용법 : 주로 다차원 배열에서 초기값을 미리 세팅해놓고 작업할때 활용하기 좋다.
+ 놀랍게도 어레인지가 아니라 arange다. 개인적으로 쓸 때 헷갈릴 뻔했다.

느낀점
------------------
C언어 위주로 공부하고 사용해온 사람이어서 그런지, 지금껏 내가 일일이 해줘야 했거나 엄청 번거로웠던 작업을 해주는 명령어들을 많이 배워서 정말 새로운 느낌이 들고, 앞으로의 코딩이 더욱 편리해지겠다는 생각이 들었다. 이번 데이터분석 스터디는 내게 있어 하나의 전환점이 될 것이라고 믿는다.
